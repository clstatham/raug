use raug::prelude::*;

// this macro generates a processor struct and implements the Processor trait for it based on the function signature and body
// the generated struct will have the name of the function converted to UpperCamelCase
// e.g. `sine_oscillator` will become `SineOscillator`
// the original function is also output by the macro for convenience and linting :)
#[processor]
pub fn sine_oscillator(
    env: ProcEnv,             // information about the processing context
    #[state] phase: &mut f32, // stateful parameter that is preserved across calls
    #[input] freq: &f32,      // input frequency
    #[output] out: &mut f32,  // output sine wave
) -> ProcResult<()> {
    *phase += 2.0 * std::f32::consts::PI * freq / env.sample_rate;
    *out = phase.sin() * 0.2;
    Ok(())
}

// we can add additional functionality to the processor struct generated by the #[processor] macro
impl SineOscillator {
    fn new() -> Self {
        SineOscillator {
            phase: 0.0,
            freq: 440.0,
        }
    }
}

fn main() {
    // initialize logging
    env_logger::init();

    // create a new graph
    let mut graph = Graph::new();

    // add a sine oscillator
    // let sine = SineOscillator::new().node(&graph, 440.0);
    let sine = graph.add_node(SineOscillator::new());
    let c440 = graph.constant(440.0);
    graph.connect(c440, 0, sine, 0);

    // add some outputs (2 for stereo)
    let out_l = graph.add_audio_output();
    let out_r = graph.add_audio_output();
    graph.connect(sine, 0, out_l, 0);
    graph.connect(sine, 0, out_r, 0);

    // open the audio stream
    graph
        .play(CpalOut::spawn(
            &AudioBackend::Default,
            &AudioDevice::Default,
        ))
        .unwrap()
        .run_for(Duration::from_secs(10))
        .unwrap();
}
